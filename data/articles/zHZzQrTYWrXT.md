# C++面向对象基础

### 封装：

就是把客观事物封装成抽象的类，并且类可以把⾃⼰的数据和⽅法只让信任的类或者对象操作，对不可信的进⾏信息隐藏。⼀个类就是⼀个封装了数据以及操作这些数据的代码的逻辑实体。在⼀个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种⽅式，对象对内部数据提供了不同级别的保护，以防⽌程序中⽆关的部分意外的改变或错误的使⽤了对象的私有部分

### 继承：

是指可以让某个类型的对象获得另⼀个类型的对象的属性的⽅法。它⽀持按级分类的概念。继承是指这样⼀种能⼒：它可以使⽤现有类的所有功能，并在⽆需新编写原来的类的情况下对这些功能进⾏扩展。通过继承创建的新类称为“⼦类”或者“派⽣类”，被继承的类称为“基类”、“⽗类”或“超类”。继承的过程，就是从⼀般到特殊的过程。要实现继承，可以通过“继承”和“组合”来实现。
继承概念的实现⽅式有两类：
实现继承：实现继承是指直接使⽤基类的属性和⽅法⽽⽆需额外编码的能⼒。
接⼝继承：接⼝继承是指仅使⽤属性和⽅法的名称、但是⼦类必需提供实现的能⼒。

**继承方式：**

public:公有继承，父类的公有和保护成员在子类中仍然是公有和保护成员，可以由派生类的成员函数来访问，派生类对象可以访问父类的公有成员。

private:私有继承，在父类的所有非私有成员在子类中一律变成子类的私有成员，子类只能通过成员函数来访问，派生类对象不能访问。

protected:(protected修饰的成员本来是私有的，但是可以被派生类的成员函数访问)保护继承，在保护继承方式下，父类的非私有成员，在派生类中都变成保护成员，这些保护成员可以被派生类的函数访问，不可以被派生类的对象访问。

```c++
#include<iostream>
using namespace std;

class A{
	
	public:
		int c;
		
	protected:
		int b;
		
	private:
		int a;
}; 

class B:public A{
	public:
		void get_c(){
			cout<<"c is: "<<c<<endl;
		}
		
		void get_b(){
			cout<<"b is: "<<b<<endl;
		}
		
		//private不能被继承，但是protected和private可以 
		
		//void get_a(){
		//	cout<<"a is: "<<a<<endl;
		//}
	
};

int main(){
	B *b=new B();
	//b->get_a();
	b->get_b();
	b->get_c();
	return 0;
}
```



### 多态：

多态其实⼀般就是指继承加虚函数实现的多态，对于重载来说，实际上基于的原理是，编译器为函数⽣成符号表时的不同规则，重载只是⼀种语⾔特性，与多态⽆关，与⾯向对象也⽆关，但这⼜是 C++中增加的新规则，所以也算属于 C++，所以如果⾮要说重载算是多态的⼀种，那就可以说：多态可以分为静态多态和动态多态。静态多态其实就是重载，因为静态多态是指在编译时期就决定了调⽤哪个函数，根据参数列表来决定；动态多态是指通过⼦类重写⽗类的虚函数来实现的，因为是在运⾏期间决定调⽤的函数，所以称为动态多态，
⼀般情况下我们不区分这两个时所说的多态就是指动态多态。
动态多态的实现与虚函数表，虚函数指针相关。

### 虚函数：

定义：虚函数是在基类中用virtual修饰的成员函数，只有成员函数可以声明为虚函数。

作用：使用虚函数可以达到动态调用该函数的目的，即实现运行时绑定。虚函数在基类和派生类之间提供了同名接口界面，即使用相同名字的虚函数可以在派生类中被重新定义。

特性：如果在父类定义了虚函数，那么它派生类里面的同名函数必定也是虚函数。通过使用指向父类的对象的指针来调用虚函数可以实现动态调用，在程序运行时才通过指向的具体对象类型来确定被调用的函数，通过虚函数可以得到统一的调用界面。

实例：

```c++
#include<iostream>
using namespace std;

class A{
	public:
	virtual void test(){
		cout<<"test:A"<<endl;
	}
	
	void test1(){
		cout<<"test1:A"<<endl;
	}
};

class B:public A{
	public:
	virtual void test(){
		cout<<"test:B"<<endl;
	}
	
	void test1(){
		cout<<"test1:B"<<endl;
	}
};

int main(){
	A *b1=new B();
	B *b=new B();
	
	b1->test();
	b->test();
	b1->test1();
	b->test1();	
	return 0;
}
```

实例中b1是一个父类指针指向子类对象，b是一个子类指针。test函数是虚函数，所以b1调用test的时候，调用的是子类中覆盖父类的虚函数。但是test1不是虚函数，b1因为是基类指针，调用的时候就会调用基类的test1函数。b是一个子类指针，调用的时候（子类方法原型和父类方法一样，如果是虚函数，则会覆盖，如果不是虚函数，会隐藏（内部变量将外部变量隐藏起来）父类所有同名的函数）直接调用B类对象里面的方法。

### 抽象类

纯虚函数：

纯虚函数是在声明虚函数的同时将其“初始化”为0的函数，虚函数必须有函数实现，而纯虚函数一般在父类中没有函数实现。纯虚函数首先必须是成员函数，并在大多数情况下属于父类。因此，在派生类中一般都必须考虑实现在父类中声明的纯虚函数。

抽象类：

一旦在某类中定义了纯虚函数，则该类只能作为父类派生其他类，不可用该类创建对象。在派生类中实现了父类所有纯虚函数，才可以用派生类创建对象，否则派生类依然只能用来派生新的派生类。使用指向抽象类的指针或引用，可以支持运行时多态性

实例：

```c++
#include<iostream>
using namespace std;

class A{
	
	public:
		virtual void test() const=0;
};

class B:public A{
	public:
		void test() const{
		cout<<"test B"<<endl;
		}
};
int main(){
	//抽象类不能实例化 
	//A a;
	
	A *b=new B();
	b->test();
	
	
	delete b;
	
	return 0;
}
```



**注意点：1.类的构造函数不可以声明为虚函数，**当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。

虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。

vptr的初始化：当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。

如果构造函数时虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化。

因此，**构造函数不可以是虚函数**。

**类的析构函数最好声明为虚函数（在从派生类一层层析构的过程中，调用的都是本类的析构函数。使用父类指针的情况下，如果不是虚析构函数，首先会调用父类的析构函数，造成对象销毁）**