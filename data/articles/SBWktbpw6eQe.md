# JAVA 面向对象特性：继承，抽象类，接口，多态，内部类，Object

### 类的继承：

多个类中存在**相同属性**和**行为**时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可

继承格式：class <子类名> extends <父类名>{}

子类只能继承父类所有非私有成员，（方法和变量），子类不能继承父类的构造方法，可以通过super关键字去访问父类构造方法。

**特点** java只支持单继承，不支持多继承，可以多层继承

### 方法重写(Override)和方法重载(Overload)的区别?

Override是覆盖的意思，也就是重写，它与返回值类型无关，只看参数列表;

Overload是重载的意思，表示在同一个类中，允许存在一个以上的同名函数，只要他们的参数个数或者参数类型不同即可;

两者不同主要体现在：目的不同、范围不同、参数要求不同、返回类型不同。

- 同:overload用于增加程序的可读性(做法不同,但是做的同一事情)。 override用于提供其超级类已经提供的方法的特定实现。
- 同:overload 在相同的类范围内内执行。 override发生在两类具有继承（继承）的关系。
- 参数要求不同:overload参数必须不同。 override参数必须相同。
- 返回类型不同:overload中可以相同或不同。 override必须是相同的或协变的。

### final关键字

被修饰类不能被继承，被修饰的方法不能被重写。fianl修饰局部变量只能赋值一次，不能修改

final修饰的引用类型的变量，只能指向一个对象，地址不能再更改

### 抽象类

抽象类就是拥有抽象方法的类，抽象类要使用abstract关键字声明

特点：

1. 抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法);
2. 抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；
3. 抽象类要使用必须依靠子类，使用extends继承，一个子类只能继承一个抽象类；
4. 一个类继承了抽象类,则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）；
5. 抽象类不能用final声明,抽象方法也不能.



### 接口

官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。

通俗解释：接口可以理解为一种特殊的抽象类，里面全部是由全局常量和公共的抽象方法所组成。接口是解决Java无法使用多继承的一种手段，但是接口在实际中更多的作用是制定标准的。或者我们可以直接把接口理解为100%的抽象类，既接口中的方法必须全部是抽象方法。

特点：

1. 接口不能被实例化;
2. 接口中的成员方法默认修饰为public abstract,成员变量默认修饰为public static final;
3. 接口没有构造方法;
4. 一个类可以实现多个接口,格式如: class A implements B,C{ }
5. 接口不能用final声明.



### 多态

1).多态概述

多态是继封装、继承之后，面向对象的第三大特性。

生活中，比如跑的动作，小猫、小狗和大象，都有跑的动作，但是跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也 是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。

父类的引用指向子类对象。

2).多态定义

多态： 是指同一行为，具有多个不同表现形式。

3).多态前提

①继承或者实现

②方法的重写

③父类引用指向子类对象

4).多态的体现格式

多态体现的格式：

父类类型 变量名 = new 子类对象；

变量名.方法名()；

代码如下：

```
Fu f = ``new` `Zi();``//父类的引用指向子类对象` `f.method();
```

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。

5).多态的好处

实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展 性与便利。

6).引用类型转换–向上转型

多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。

当父类引用指向一个子类对象时，便是向上转型.

7).引用类型转换–向下转型

父类类型向子类类型向下转换的过程，这个过程是强制的。

一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。

8).instanceof

instanceof 关键字：判断变量是否属于某个类，返回值为true/false

### 内部类

1).什么是内部类

将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。

2).什么是成员内部类

定义在类中方法外的类。

定义格式：

```
class` `外部类 {  `
`  ``class` `内部类{ `
` ` 
`  ``}`
`  ` 
`} 
```

3).内部类使用场景

在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机 类 Engine ，这时， Engine 就可以使用内部类来描述，定义在成员位置。

4).内部类访问特点

内部类可以直接访问外部类的成员，包括私有成员。

外部类要访问内部类的成员，必须要建立内部类的对象。

内部类可以声明为static的，但此时就不能再使用外层封装类的非static的成员变量；

非static的内部类中的成员不能声明为static的，只有在顶层类或static的内部类中才可声明static成员；

创建内部类对象格式：

外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；

代码演示：

```
public` `class` `Person {  `
`  ``private` `boolean` `live = ``true``;  `
`  ``class` `Heart {    `
`    ``public` `void` `jump() {      `
`    ``// 直接访问外部类成员      `
`      ``if` `(live) {        `
`        ``System.out.println(``"心脏在跳动"``);      `
`      ``} ``else` `{        `
`        ``System.out.println(``"心脏不跳了"``);      `
`      ``}    `
`    ``}  `
`  ``}`
` ` 
`  ``public` `boolean` `isLive() {    `
`    ``return` `live;  `
`  ``}`
` ` 
`  ``public` `void` `setLive(``boolean` `live) {`
`    ``this``.live = live;  `
`  ``}`
`}`
 
`public` `class` `InnerDemo {  `
`  ``public` `static` `void` `main(String[] args) {    `
`    ``// 创建外部类对象     `
`    ``Person p = ``new` `Person();    `
`    ``// 创建内部类对象    `
`    ``Heart heart = p.``new` `Heart();        `
`    ``// 调用内部类方法    `
`    ``heart.jump();    `
`    ``// 调用外部类方法    `
`    ``p.setLive(``false``);    `
`    ``// 调用内部类方法    `
`    ``heart.jump();  `
`  ``} `
`}
```

### 匿名内部类

1).匿名内部类概述

匿名内部类是内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象。开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作，

\1. 定义子类

\2. 重写接口中的方法

\3. 创建子类对象

\4. 调用重写后的方法

我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。

2).匿名内部类前提

匿名内部类必须继承一个父类或者实现一个父接口。

格式：

```
new 父类名或者接口名(){
    // 方法重写
    @Override
    public void method() {
        // 执行语句
    }
};
```

3).匿名内部类使用

```
//定义接口
public interface FlyAble{   
    void fly();
}
  
//创建测试类
public class InnerDemo {   
    public static void main(String[] args) {     
    /*       
    1.等号右边:是匿名内部类，定义并创建该接口的子类对象       
    2.等号左边:是多态赋值,接口类型引用指向子类对象      
    */     
        FlyAble  f = new FlyAble(){       
        public void fly() {         
            System.out.println("我飞了~~~");       
            }     
        };
  
        //调用 fly方法,执行重写后的方法     
        f.fly();   
    }
}
```

### Object类

1).Object类概述

Object 类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。如果一个类没有特别指定父类， 那么默认则继承自Object类。

2).toString方法

返回该对象的字符串表示。

toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。

在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。

重写toString方法演示：

```
public class Person { 
    private String name;
    private int age;
    @Override
    public String toString() {
        return "Person{" + "name='" + name + '\'' + ", age=" + age + '}';
    }
    // 省略构造器与Getter Setter
}
```

3).equals方法

指示其他某个对象是否与此对象“相等”。

调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。

默认地址比较：

如果没有覆盖重写equals方法，那么Object类中默认进行 == 运算符的对象地址比较，只要不是同一个对象，结果必然为false。

自定义对象内容比较：

如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。

equals方法必须满足以下特点：

- 自反性（x.equals(x)必须返回true）、
- 对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、
- 传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）、
- 一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。

重写equals方法演示：

```
import java.util.Objects;
public class Person {  
        private String name;    
        private int age;    
    
    @Override
        public boolean equals(Object o) {
        // 如果对象地址一样，则认为相同
        if (this == o)
            return true;
        // 如果参数为空，或者类型信息不一样，则认为不同
        if (o == null || getClass() != o.getClass())
            return false;
        // 转换为当前类型
        Person person = (Person) o;
        // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果
        return age == person.age && Objects.equals(name, person.name);
    }
}
```

实现高质量的equals方法：

 

\1. 使用==操作符检查“参数是否为这个对象的引用”；

\2. 使用instanceof操作符检查“参数是否为正确的类型”；

\3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；

\4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；

\5. 重写equals时总是要重写hashCode；

\6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。

4).hashCode方法

返回该对象的哈希码值。

该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。

一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。

5).getClass方法

返回次Object的运行时类类型。
不可重写，要调用的话，一般和getName()联合使用，如getClass().getName();

6).finalize方法

对象被回收之前要做的事。

7).clone方法

实现对象的浅克隆。

------