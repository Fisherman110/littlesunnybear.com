# c/c++ 关键字

### const

const 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。

C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。

const int MaxNum=100; //此变量不能修改

const和指针：const可以和指针变量一起使用，这样可以限制指针变量本身，也可以限制指针指向的数据：

```
const int *p1;//p1指向的数据不能修改，但是p1本身可以修改
int const *p2;//p2指向的数据不能修改，p2本身可以修改
int * const p3;//p3本身不能修改
```



### typedef

C语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样。起别名的目的不是为了提高程序运行效率，而是为了编码方便。

例如：typedef oldName newName;

```
typedef int INTEGER;

INTERGER a,b;

a=1,b=2;
```

```
typedef struct stu{
     char name[20];
     int age;
     char sex;
 } STU;
```

STU是struct stu的别名，可以使用STU定义结构体变量： STU body1,body2/等价 struct stu body1,body2;

```
typedef char ARRAY20[20];
ARRAY20 a1,a2,a2;//等于 char a1[20],a2[20],a3[20]
```

标识ARRAY20是char[20]的别名，它是一个长度为20的数组类型

**注意**  typedef 在表现上有时候类似于 #define，但它和宏替换之间存在一个关键性的区别。正确思考这个问题的方法就是把 typedef 看成一种彻底的“封装”类型，声明之后不能再往里面增加别的东西。

在连续定义几个变量的时候，typedef 能够保证定义的所有变量均为同一类型，而 #define 则无法保证。

### define

```
#define N 100
int sum=20+N

#undef N
```

1) 宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单粗暴的替换。字符串中可以含任何字符，它可以是常数、表达式、if 语句、函数等，预处理程序对它不作任何检查，如有错误，只能在编译已被宏展开后的源程序时发现。
2) 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换。
3) 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用`#undef`命令。
4) 代码中的宏名如果被引号包围，那么预处理程序不对其作宏代替
5) 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换

### auto

 C++ 11 以来，**auto** 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符

```

auto f=3.14;      //double
auto s("hello");  //const char*
auto z = new auto(9); // int*
auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型

```

### register

**register** 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

### static

**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

### extern

**extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。可以这么理解，*extern* 是用来在另一个文件中声明一个全局变量或函数。

extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：

第一个文件：main.cpp

```

#include <iostream>
 
int count ;
extern void write_extern();
 
int main()
{
   count = 5;
   write_extern();
}

```

第二个文件：support.cpp

```

#include <iostream>
 
extern int count;
 
void write_extern(void)
{
   std::cout << "Count is " << count << std::endl;
}
```

### 强制转换

```
//c语言风格
int i=10;
char c=(char)i;
//c++新增
char d=char(i);
```

### 内联函数

如果函数平凡调用，可以将函数的代码嵌入到每一个调用处（函数返回类型前面添加关键字inline） 



### new/delete

进行堆内存的分配和释放，类似c里面的malloc()和free()

new的使用：

指针变量=new 类型；

指针变量=new 类型（初值）;

指针变量=new 类型[数组元素数];

new的返回值，若是非数组类型，返回指向该类型对象的指针，若是数组类型，返回数组的首地址。new申请堆内存不一定会成功，不成功时返回NULL。new为数组申请堆内存时无法提供初始值。

delete的使用：

delete 指针变量;  释放指针变量所指向的堆内存

delete [] 指针变量；释放为数组分配的堆内存
