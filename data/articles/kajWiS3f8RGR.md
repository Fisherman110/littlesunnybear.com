# JAVA多线程

### 1.线程概述

1).进程

程序（program）是对数据描述与操作的代码的集合，是应用程序执行的脚本。

进程（process）是程序的一次执行过程，是系统运行程序的基本单位。程序是静态的，进程是动态的。系统运行一个程序即是一个进程从创建、运行到消亡的过程。

多任务（multi task）在一个系统中可以同时运行多个程序，即有多个独立运行的任务，每个任务对应一个进程。

2).线程

线程（thread）：比进程更小的运行单位，是程序中单个顺序的流控制。一个进程中可以包含多个线程。

简单来讲，线程是一个独立的执行流，是进程内部的一个独立执行单元，相当于一个子程序。

一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。

操作系统给每个线程分配不同的CPU时间片，在某一时刻，CPU只执行一个时间片内的线程，多个时间片中的相应线程在CPU内轮流执行。

3).多线程应用场景

VNC同时共享屏幕给多个电脑

迅雷开启多条线程一起下载

QQ同时和多个人一起视频

服务器同时处理多个客户端请求

4).并行和并发

并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)

并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于间时间隔较短，使人感觉两个任务都在运行

5).Java程序运行原理

Java命令会启动java虚拟机(JVM)，等于启动了一个应用程序，也就是启动了一个进程。

该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法

一个应用程序有且只有一个主线程,程序员不能New主线程，可以New子线程。

6).思考:JVM启动的是多线程吗？

JVM启动至少启动了**垃圾回收线程**和**主线程**，所以是多线程的



### 2.线程的创建

每个Java程序启动后，虚拟机将自动创建一个主线程,可以通过以下两种(其实有三种)方式自定义线程类：

### 方式一:继承Thread类

**实现步骤：**

1.定义类继承Thread类

2.重写run方法

3.把新线程要做的事写在run方法中

4.创建线程对象

5.开启新线程, 内部会自动执行run方法

```java
class MyThread extends Thread{
    @Override
    public void run() {
        System.out.println("子线程任务");
    }
}
 
 
public class Demo01 {
    public static void main(String[] args) {
        /*主线程，程序员不能创建，程序员只能创建子线程*/
         
        //1.创建子线程对象
        MyThread t1 = new MyThread();
        //2.启动子线程
        t1.start();
  }
}
```

### 方式二:实现Runnable接口

**实现步骤：**

1.定义类实现Runnable接口

2.实现run方法

3.把新线程要做的事写在run方法中

4.创建自定义的Runnable的子类对象,创建Thread对象传入Runnable

5.调用start()开启新线程, 内部会自动调用Runnable的run()方法

```java
class  MyThread  implements Runnable{
    @Override
    public void run() {
        System.out.println("子线程任务");
    }
}
 
 
 
public class Demo01 {
    public static void main(String[] args) {
/*  线程实现的方式 (2) - 定义类实现Runnable接口*/
        //1.创建runable对象
        MyThread  task = new MyThread  ();
         
        //2.创建Thread对象
        Thread t1 = new Thread(task);
         
        //3.启动线程
        t1.start();
  }
}
```

### 3.匿名内部类实现线程的两种方式

```java
public static void main(String[] args) {
        new Thread(){
            public void run() {
                System.out.println("任务1...." + Thread.currentThread());
            };
        }.start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("任务2...." + Thread.currentThread());
            }
        }).start();
    }
}
```

### 4.线程的常用方法

1).获取当前线程的对象

currentThread()方法用于获取当前线程对象

在不同的方法中，获取的线程对象名称是有可能不一样的

在main中获取的是**主线程对象**

在子线程的run方法中获取的是**子线程对象**

2).获取线程名字和设置名字

通过Thread的getName()方法获取线程对象的名字

通过setName(String)方法可以设置线程对象的名字

通过构造函数可以传入String类型的名字

每个线程系统都会默认分配个名字,**主线程：main,****子线程thread-0 ....**

3).线程休眠

Thread.sleep(毫秒), 控制当前线程休眠若干毫秒

1秒= 1000毫秒

1秒 = 1000毫秒* 1000微妙 * 1000纳秒（1000000000 ）

4).守护线程

setDaemon(), 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出.

特点：男守护女，女的死，男的也不想活了

5).加入线程

join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续

join(int), 可以等待指定的毫秒之后继续

6).线程让出

yield() 让出cpu

7).线程优先级

setPriority()设置线程的优先级

默认优先级是5，最小优先级1，最高优先级10

可以设置2，3，4

Thread里面有静态常量

### 5.进程同步

1).什么是同步

是多个线程同时访问同一资源时，需等待某个线程对资源访问结束，下个线程才能进行访问,浪费时间，效率低,但是可以保证数据安全.

同步就是加锁，不让其它人访问,synchronized指的就是同步的意思.

2).什么情况下需要同步

当多线程并发, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步,否则会有线程安全问题.

3).同步代码块

使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块

多个同步代码块如果使用相同的锁对象, 那么他们就是同步的

使用同步锁时，应该尽是让锁的范围小点，才能提高性能

4).同步方法

使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的

非静态同步方法的锁是:this

静态同步方法的锁是:字节码对象(xx.class)



锁的总结:

同步代码块使用的锁可以是任意对象的。因为synchronized中的对象可以我们自己指定。

同步函数使用的锁是固定的this。当线程任务只需要一个同步时完全可以使用同步函数。

同步代码块使用的锁可以是任意对象。当线程任务中需要多个同步时，必须通过锁来区分，这时必须使用同步代码块。同步代码块较为常用。

静态方法是随着类的加载而加载，静态同步函数使用的锁是字节码class文件对象。

回顾线程安全的类:

Vector,StringBuffer,Hashtable

Vector是线程安全的,ArrayList是线程不安全的

StringBuffer是线程安全的,StringBuilder是线程不安全的

Hashtable是线程安全的,HashMap是线程不安全的

### 6.单例模式

单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。

实现步骤:

第一步:将类的构造函数申明为私有;

第二步:在类中初始化一个类;

第三步:对外提供访问该类的公开方法,并返回第二步中实例化的类;

1).饿汉式

```java
class Single
{
    private static final Single s = new Single();
 
    private Single(){}
 
    public static Single getInstance()
    {
        return s;
    }
}
```

2).懒汉式

```java
class Single{
    private static  Single s = null;
    private Single(){}
    public static  Single getInstance() {
        if(s==null) {
            s = new Single();
        }
        return s;
    }
}
```

3).解决单例懒汉式的并发问题

```java
class Single
{
    private static  Single s = null;
    private Single(){}
    /*
    并发访问会有安全隐患，所以加入同步机制解决安全问题。
    但是，同步的出现降低了效率。
    可以通过双重判断的方式，解决效率问题，减少判断锁的次数。
    */
    public static  Single getInstance()
    {
        if(s==null)
        {
            synchronized(Single.class)
            {
                if(s==null)
                    s = new Single();
            }
        }
        return s;
    }
}
```

### 7.死锁

1).死锁的概念

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

2).死锁的理解

在一条河上有一座桥，桥面较窄，只能容纳一辆汽车通过，无法让两辆汽车并行。如果有两辆汽车A和B分别由桥的两端驶上该桥，则对于A车来说，它走过桥面左面的一段路（即占有了桥的一部分资源），要想过桥还须等待B车让出右边的桥面，此时A车不能前进；对于B车来说，它走过桥面右边的一段路（即占有了桥的一部分资源），要想过桥还须等待A车让出左边的桥面，此时B车也不能前进。两边的车都不倒车，结果造成互相等待对方让出桥面，但是谁也不让路，就会无休止地等下去。这种现象就是死锁。如果把汽车比做进程，桥面作为资源，那麽上述问题就描述为：进程A占有资源R1，等待进程B占有的资源Rr；进程B占有资源Rr，等待进程A占有的资源R1。而且资源R1和Rr只允许一个进程占用，即：不允许两个进程同时占用。结果，两个进程都不能继续执行，若不采取其它措施，这种循环等待状况会无限期持续下去，就发生了进程死锁。

3).产生死锁的必要条件

〈1〉互斥条件。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。

〈2〉不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。

〈3〉占有且申请条件。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）。甲过不去，前进不能，又不后退；乙也处于同样的状况。

〈4〉循环等待条件。存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。



等待/唤醒机制：

wait(): 会让线程处于等待状态，其实就是将线程临时存储到了线程池中。

notify():会唤醒线程池中任意一个等待的线程。

notifyAll():会唤醒线程池中所有的等待线程。

记住：这些方法必须使用在同步中，因为必须要标识wait，notify等方法所属的锁。同一个锁上的notify，只能唤醒该锁上的被wait的线程。

为什么这些方法定义在Object类中呢？

因为这些方法必须标识所属的锁，而锁可以是任意对象，任意对象可以调用的方法必然时Object类中的方法。